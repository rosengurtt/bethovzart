import { Injectable } from '@angular/core';

@Injectable()
export class SongDisplayService {

    noteOn: number = 9;
    noteOff: number = 8;
    tracks: any;
    noTracks: number;
    noTracksWithNotes: number = 0;
    songDuration: number;
    svgBox: any;
    svgns: string = "http://www.w3.org/2000/svg";
    svgBoxWidth: number;
    svgBoxHeight: number;
    separationBetweenTracks: number = 15;
    trackHeight: number;
    model: any;

    songDisplay(songData:any) {
            this.tracks = this.getNotesSequences(songData.track);
            this.noTracks = this.tracks.length;
            for (let t = 0; t < this.noTracks; t++) {
                if (this.tracks[t].notes.length > 0) this.noTracksWithNotes++;
            }
            this.svgBox = document.getElementById("svgBox");
            this.svgBoxWidth = this.svgBox.clientWidth;
            this.svgBoxHeight = this.svgBox.clientHeight;
            this.trackHeight = (this.svgBoxHeight / this.noTracksWithNotes) - (this.separationBetweenTracks * (this.noTracksWithNotes - 1)) / 2;
            this.model = document.getElementById("note");

            this.songDuration = this.getSongDuration(this.tracks);
            this.Draw();
    }

    private Draw() {
        let i = -1; //this index corresponds to tracks shown (we show only tracks with notes)
        for (let n = 0; n < this.tracks.length; n++) {
            if (this.tracks[n].notes.length === 0) continue;
            i++;
            let verticalScale = this.trackHeight / (this.tracks[n].maxPitch - this.tracks[n].minPitch);

            let horizontalScale = this.svgBoxWidth / this.songDuration;
            let verticalShift = ((i + 1) * (this.trackHeight)) + (i * this.separationBetweenTracks);
            let noteSeq = this.tracks[n].notes;
            console.log("verticalShift" + verticalShift);
            for (let m = 0; m < noteSeq.length; m++) {
                let note = noteSeq[m];
                let cx = note[0] * horizontalScale;
                let cy = verticalShift - ((note[1] - this.tracks[n].minPitch) * verticalScale);
                let copy = this.model.cloneNode(true);
                copy.setAttributeNS(null, "cx", cx);
                copy.setAttributeNS(null, "cy", cy);
                this.svgBox.appendChild(copy);
            }
        }

    }

    //Returns the lowest and highest pitches in a track
    private getTrackRange(t) {
        let min = 500;
        let max = 0;
        for (let i = 0; i < t.length; i++) {
            let pitch = t[i][1];
            if (pitch < min) min = pitch;
            if (pitch > max) {
                max = pitch;
            }
        }
        return [min, max];
    }

    //Returns the number of ticks in the whole song
    private getSongDuration(tracks) {
        let duration = 0;
        for (let i = 0; i < tracks.length; i++) {
            if (tracks[i].notes.length > 0) {
                let trackLength = tracks[i].notes.length;
                let lastNote = tracks[i].notes[trackLength - 1]
                let timeStartsLastNote = lastNote[0];
                let durationLastNote = lastNote[2];
                let endTrack = timeStartsLastNote + durationLastNote;
                if (endTrack > duration) {
                    duration = endTrack;
                }
            }
        }
        return duration;
    }
    // Returns an array of objects that have: an array with the notes, and the max and min pitch
    private getNotesSequences(midiTracks) {
        let musicTracks = [];
        for (let k = 0; k < midiTracks.length; k++) {
            let trackNotes = this.getNotes(midiTracks[k]);
            musicTracks[k] = {};
            musicTracks[k].notes = trackNotes;
            let songRange = this.getTrackRange(trackNotes);
            musicTracks[k].maxPitch = songRange[1];
            musicTracks[k].minPitch = songRange[0];
        }
        return musicTracks;
    }

    //returns an array of triplets [x,y,z] where
    // x = number of ticks from beginning of the songData
    // y = pitch
    // z = volume
    private getNotes(midiTrack) {
        let returnArray = [];
        let timeSinceStart = 0;
        let trackLength = midiTrack.length;
        for (let i = 0; i < trackLength; i++) {
            let midiEvent = midiTrack[i];
            timeSinceStart += midiEvent.delta;
            //Loof for note one events         
            if (midiEvent.type === 8 && midiEvent.subtype === this.noteOn) {
                let pitch = midiEvent.param1;
                let duration = 0;
                //Find corresponding note off
                for (let j = i + 1; j < trackLength; j++) {
                    let nextEvent = midiTrack[j];
                    duration += nextEvent.delta;
                    if (nextEvent.type === 8 && nextEvent.subtype === this.noteOff && nextEvent.param1 === pitch) {
                        //Found the note off, save the point
                        returnArray.push([timeSinceStart, pitch, duration]);
                        break;
                    }
                }
            }
        }
        return returnArray;
    }

}